import { ethers, providers } from "ethers";
import WalletConnect from "@walletconnect/web3-provider/dist/umd/index.min.js";
export const initProvider = async (provider) => {
  switch (provider) {
    case "metamask":
      return initMetamask();
    case "walletconnect":
      return initWalletConnect();
  }
};
const initMetamask = () => {
  const anyWindow = window;
  if (!anyWindow.ethereum) {
    alert("Metamask is not available, try another wallet");
  }
  anyWindow.ethereum.request({ method: "eth_requestAccounts" });
  return new ethers.providers.Web3Provider(anyWindow.ethereum);
};
const initWalletConnect = async () => {
  const wc = new WalletConnect({
    infuraId: "d07df9fba8464ef487632e9ff4ab79ce"
  });
  await wc.enable();
  const provider = new providers.Web3Provider(wc);
  return provider;
};
const connectWallet = (provider) => {
  return new Promise(async (resolve, reject) => {
    try {
      const signer = provider.getSigner();
      resolve(signer.getAddress());
    }
    catch (error) {
      console.error("[connectWallet]: ", error);
      reject(error);
    }
  });
};
export const connectAccount = async (walletType) => {
  const provider = await initProvider(walletType);
  try {
    const currentAddress = await connectWallet(provider);
    const address = currentAddress;
    const networkId = (await (await provider).getNetwork()).chainId;
    const signer = await (await provider).getSigner();
    const balance = await signer.getBalance();
    return { address, networkId, provider, balance };
  }
  catch (error) {
    console.error("[connectAccount]", error);
  }
};
